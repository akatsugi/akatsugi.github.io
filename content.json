{"meta":{"title":"akatsugi","subtitle":"呜啦啦啦","description":null,"author":"akatsugi","url":"https://akatsugi007.com","root":"/"},"pages":[{"title":"about","date":"2021-11-07T13:12:09.000Z","updated":"2021-11-07T13:12:33.887Z","comments":true,"path":"about/index.html","permalink":"https://akatsugi007.com/about/index.html","excerpt":"","text":"阿巴阿巴"},{"title":"标签","date":"2021-11-07T13:29:16.000Z","updated":"2021-11-07T13:48:47.516Z","comments":true,"path":"tags/index.html","permalink":"https://akatsugi007.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Security","slug":"SpringSecurity/SpringSecurity","date":"2021-11-07T12:12:51.033Z","updated":"2021-11-07T13:35:33.323Z","comments":true,"path":"2021/11/07/SpringSecurity/SpringSecurity/","link":"","permalink":"https://akatsugi007.com/2021/11/07/SpringSecurity/SpringSecurity/","excerpt":"SpringSecurityCSDN实例 基本原理SpringSecurity本质是一个过滤器链","text":"SpringSecurityCSDN实例 基本原理SpringSecurity本质是一个过滤器链 FilterSecurityInterceptor：方法级的权限过滤器，基本位于过滤链的最底部 ExceptionTranslationFilter:异常过滤器，用来处理再认证授权过程中抛出的异常 这两个Filter通常是结合在一起用的，前者负责处理后者所抛出的异常并做相应的处理，后者主要用于鉴权。ExceptionTranslationFilter在处理异常时，如果异常为AuthenticationException类型，表示用户认证都失败了(比如还没有经过认证)，此时将调用AuthenticationEntryPoint开启认证过程，比如向用户展示登录页面；如果异常为AccessDeniedException，表示用户可能已经登录但是没有足够的权限，此时将调用AccessDeniedHandler，比如向用户展示“你没有权限”的通知页面。 UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中用户名密码 用于处理基于Form登录的认证，认证成功重定向到指定页面，认证失败向用户重新返回登录界面并提示错误。UsernamePasswordAuthenticationFilter继承自AbstractAuthenticationProcessingFilter，AbstractAuthenticationProcessingFilter可以配置一个AuthenticationSuccessHandler和一个AuthenticationFailureHandler，认证成功之后将调用AuthenticationSuccessHandler，比如像UsernamePasswordAuthenticationFilter一样重定向到某个页面，也可以根据自定义向用户返回一个JWT的Token；认证失败(比如用户名或密码不正确)后将调用AuthenticationFailureHandler，比如像UsernamePasswordAuthenticationFilter一样重新返回登录页面，也可以根据自定义向用户返回一个401状态码。 AbstractAuthenticationProcessingFilter并不完成认证逻辑，而是将其交给AuthenticationManager，AuthenticationManager进而代理给AuthenticationProvider，AuthenticationProvider验证用户提供的凭证是否正确(比如从数据库加载用户的密码然后与用户提供的密码对比，或者与LDAP服务器通信验证用户名和密码)。 过滤器加载 使用SpringSecurity配置过滤器 DelegatingFilterProxy UserDetailsService接口自定义账号密码逻辑，数据库？内存？ （redis? 查询数据库用户名和密码的过程 创建类继承UsernamePasswordAuthenticationFilter，重写其中三个方法 attemptAuthentication 判断用户名密码 successfulAuthentication 成功 unsuccessfulAuthentication 失败 创建类实现UserDetailsService接口，编写查询数据过程，返回User对象（User对象是安全框架提供的对象） PasswordEncoder对密码加密接口 12BCryptPasswordEncoder bCryptPasswordEncoder =new BCryptPasswordEncoder();String pwd=bCryptPasswordEncoder.encode(&quot;password&quot;); web权限方案认证与授权 设置登录用户名密码 配置文件 application.properties中 spring.security.user.name= spring.security.user.password= 配置类 @Configuration extends WebSecurityConfigurerAdapter 自定义实现类UserDetailsService 创建配置类，设置使用哪个userDetailsService实现类 编写实现类，返回User对象，User对象有用户名密码和操作 数据库 引入依赖 创建数据库 创建实体类Users 创建mapper接口,interface UserMapper ,增删改查函数 mapper.xml文件对应接口的增删改查 (使用MyBatis-Plus可简化45，接口继承BaseMapper&lt;Users&gt;) 在UserDetailsService的自定义实现类中调用mapper中的方法查询数据库对用户的认证信息（根据username查询） 在启动类中添加@MapperScan(“Mapper所在包”)注释 配置文件中配置数据库信息 springBoot2默认使用Mysql8;driver-class-name加cj;设置时区 配置类configure设置自定义登录页面、403页面等 基于角色和权限实现访问控制1. hasAuthority如果当前主体具有指定的权限，有则返回true，否则false 2. hasAnyAuthority 3. hasRole底层代码中将role改为了ROLE_#{role} 4. hasAnyRole同上 注解使用@Secured判断用户是否具有角色（其中匹配的字符串需要加上前缀”ROLE_”) 开启注解功能@EnableGlobalMethodSecurity(securedEnable=true) 在控制器方法上放添加@Secured(&#123;&quot;ROLE_normal&quot;,&quot;ROLE_admin&quot;&#125;) @PreAuthorize在进入方法前进行权限验证 @PreAuthorize(&quot;hasAnyAuthority(&#39;admins&#39;)&quot;)四个方法都可以填在( )里面 开启注解功能@EnableGlobalMethodSecurity(prePostEnabled=true) @PostAuthorize方法执行之后进行权限验证，多用于返回值 开启注解功能@EnableGlobalMethodSecurity(prePostEnabled=true) @PostAuthorize(&quot;hasAnyAuthority(&#39;admins&#39;)&quot;)四个方法都可以填在( )里面 test: ↑有输出但跳转到403页面 @PostFilter不常用 对返回数据进行过滤 @PreFilter不常用 对传入方法的数据进行过滤 用户注销配置类中添加退出配置 http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/index&quot;).permitAll() 退出超链接： &lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt; 基于数据库实现自动登录“自动登录”“十天内免登陆”…. cookie技术 安全框架实现 原理 具体实现 创建数据库 JdbcTokenRepositoryImpl中有建表sql语句 修改配置类：注入数据源，配置操作数据库对象 123456789@Autowiredprivate DataSource dataSource;@Bean public PersistenTokenRepository persistenTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); // jdbcTokenRepository.setCreateTableOnStartup(true) 自动创建数据库表 return jdbcTokenRepository;&#125; 3. 自动登录复选框 1&lt;input type=&quot;checkBox&quot; name=&quot;remeber-me&quot;/&gt; CSRF跨站请求伪造 form中加入以下语句 1&lt;input type=&quot;hidden&quot; th:name=&quot;$&#123;_csrf.parameterName&#125;$&quot; th:value=&quot;$&#123;_csrf.token&#125;$&quot;/&gt; csrfFilter.class 微服务 微服务的每个模块都相当于一个单独的项目，代码量明显减少，遇到的问题也相对来说比较好解决 微服务的每个模块可以使用不同的存储方式(redis/mysql/etc）数据库也是每个模块对应自己的数据库 每个模块可以使用不同的开发技术、开发语言，开发模式更灵活 实例 源码分析 UsernamePasswordAuthenticationFilter 查询Filter父类AbstractAuthenticationProcessingFilter的doFilter() 判断提交方式是否是post提交 调用子类的方法attemptAuthentication(request,response)进行身份验证 认证信息存入Authentication对象中 session策略处理 认证失败抛出异常，执行认证失败的方法unsuccessfulAuthentication() 认证成功执行认证成功的方法 attemptAuthentication(request,response) 判断是否是post提交，不是则抛出异常 获取表单提交的数据 使用获取数据，构造成对象，标记成未认证状态，把请求中的一些属性信息设置到对象里，调用方法进行身份认证(userDetailsService) UsernamePasswordAuthencationToken构建过程","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://akatsugi007.com/tags/Spring/"}]},{"title":"Redis","slug":"Redis/redis","date":"2021-11-07T11:20:27.189Z","updated":"2021-11-07T13:35:32.628Z","comments":true,"path":"2021/11/07/Redis/redis/","link":"","permalink":"https://akatsugi007.com/2021/11/07/Redis/redis/","excerpt":"Redis数据类型STRING二进制安全，可以包含任何数据 大小上下512M LIST","text":"Redis数据类型STRING二进制安全，可以包含任何数据 大小上下512M LIST 字符串列表 按照插入顺序排序 头部LEFT 尾部RIGHT HASH类似Java.Map 键值对集合 用于存储对象 SETSTRING 类型的无序集合 内容不重复 ZSETSET+ 每个元素都会关联一个double 类型的分数score score可重复 命令key相关set,del,dump,exists,ttl,expire,persist,pexpire,pttl,keys set：插入记录，返回OK成功，重复插入统一个值显示OK，但只要一条记录 get：获取key中的值，无值返回(nil) del：删除记录，成功显示(interger) 1 dump：序列化给定的key exist：查询给定的Key是否存在，存在返回(interger) 1，否则返回(interger) 0 ttl:查询超时时间 单位s，-1表示key存在且未设置过期时间，-2表示key不存在或已过期 pttl：查询超时时间，单位ms expire:设置过期时间s pexire:设置过去时间ms persisit:移出key的过期时间 keys：查询匹配的所有key STRINGappend,decr,decrby,get,getrange,getset,incr,incrby,incrbyfloat,mget,mset,setex,psetex,setnx,msetnx,setrange,strlen append: decr:+1 decrby: +value get getrange : get start~end getset: get 并set mget,mset：批量get,set setex: set并设置过期时间 psetex setnx:不存在时set,成功返回1，失败（已存在）返回0 msetnx:批量setnx，如果有一个存在，则都不执行 setrange:定位set，已存在点覆盖，无值点’\\x00’ strlen STRING中的BIT1getbit,setbit,bitop,bitcount,bitpos listlpush,lrange,rpush,rpop,lpop,lindex,ltrim,blpop lpush list value： 从左到右，在list的头部插入数据 rpush list value：从左到右，在list的尾部插入数据 lrange list start end:从左到右显示数据 rpop list:弹出list尾部数据 lpop list:弹出list头部数据 lindex list index:显示指定下标的数据 ltrim list start end:修剪list中start~end以外的部分 blpop list timeout : 阻塞式弹出list最左边的数据，若list为空则阻塞timeout秒 set1sadd,srem,sismember,scard,smember,srandmember,spop,smov,sdiff,sdiffstore,sinter,sintersotre,sunion,sunionstore sadd set value:添加 srem set value:删除 sismember set value:判断value是否是set的成员 scard set:set的元素个数 smember set:输出set的元素 srandmember set [count=1]:随机输出count个元素， 0&lt;count&lt;scard ：随机输出count个元素； count&gt;scard：输出scard个元素； -scard&lt;count&lt;0:随机输出count个元素； count&lt;-scard：随机输出count个元素，可重复 sdiff s1 s2:s1-s2差集 … hash1hset,hget,hmset,hmget,hdel,hsetnx,hvals,hkeys,hgetall,hexists,hincrby,hincrbyfloat,hlen,hstrlen zset1zadd,zscore,zrange,zrevrange,zcard,zcount,zrangebyscore,zrank,zrevrank,zincrby,zinterstore,zrem,zlexcount,zrangebylex zadd zset member score [member score …] ：增 zscore zset member:查score zrange zset start end :查 zcard zset zcount zset min max zrank zset member .. zlexcount zset min max:集合中score相同时，字典序下指定成员之间的数量 zrangebylex zset min max：集合中score相同时，字典序下指定成员之间排列 发布订阅subscribe publish 事务MULTI 事务异常WATCH 快照持久化 AOF持久化SpringBoot整合 导入启动器包 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接信息 12345678910111213spring: redis: host: 127.0.0.1 port: 6379 password: 123456 jedis: pool: max-active: 8 max-wait: -1 max-idle: 500 min-idle: 0 lettuce: shutdown-timeout: 0 测试 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class Test_1&#123; @Autowired private RedisTemplate&lt;String,String&gt;redisTemplate; @Test public void set()&#123; redisTemplate.opsForValue().set(&quot;myKey&quot;,&quot;myValue&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;myKey&quot;)); &#125;&#125; 配置序列化器不配置序列化器，运行会显示乱码 CSDN教程 entity 实现序列化接口Serializable 配置类设置序列化器 1234567891011121314@Configurationpublic class RedisConfig&#123; @Bean public RedisTemplate&lt;String, Days&gt;redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Days&gt;template=new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //设置key的序列化器 template.setKeySerializer(new StringRedisSerializer()); //设置value的序列化器 template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Days.class)); return template; &#125;&#125; 测试类: @Autowired 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123; @Autowired private RedisTemplate&lt;String,Days&gt; redisTemplate; private Days d; @Before public void before()&#123; d=new Days(); d.setDate(&quot;123&quot;); d.setDaysId(&quot;456&quot;); d.setItemNumber(123); d.setOpenId(&quot;dawda&quot;); d.setTitle(&quot;title&quot;); &#125; @Test public void testSet()&#123; this.redisTemplate.opsForValue().set(&quot;days&quot;,d); System.out.println((redisTemplate.opsForValue().get(&quot;days&quot;))); &#125;&#125;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://akatsugi007.com/tags/Redis/"}]},{"title":"Dubbo","slug":"Dubbo/dubbo","date":"2021-11-07T11:19:54.236Z","updated":"2021-11-07T13:35:31.963Z","comments":true,"path":"2021/11/07/Dubbo/dubbo/","link":"","permalink":"https://akatsugi007.com/2021/11/07/Dubbo/dubbo/","excerpt":"Dubbo设计架构 基本流程： Container 启动服务 Provider将服务注册到注册中心zk中去 Consumer向注册中心订阅服务 Registry向消费者返回响应服务的Provider Consumer向服务提供者调用服务，二者间建立联系，自此可以不再需要Zk Monitor实时监控连接情况、点击次数（没有Monitor也不影响运行）","text":"Dubbo设计架构 基本流程： Container 启动服务 Provider将服务注册到注册中心zk中去 Consumer向注册中心订阅服务 Registry向消费者返回响应服务的Provider Consumer向服务提供者调用服务，二者间建立联系，自此可以不再需要Zk Monitor实时监控连接情况、点击次数（没有Monitor也不影响运行） 注册中心 Zookeeper Dubbo-admin 示例公共接口 提供接口定义和bean类定义实现 导入dubbo 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 服务器提供者 提供服务接口的实现 导入公共接口 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubbo.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 服务消费者 提供消费者接口的实现 导入公共接口 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubbo.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 消费者远程调用提供者的服务步骤： 服务提供者注册到注册中心//暴露服务 pom.xml 引入dubbo依赖、引入ZooKeeper客户端 配置服务提供者provider.xml （spring xml） 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.8&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 1. 指定当前服务/应用的名字，与服务名相同 --&gt; &lt;dubbo:application name=&quot;user-service-gmall&quot; &gt;&lt;/dubbo:application&gt; &lt;!-- 2.使用zookeeper注册中心暴露服务地址 --&gt;&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;--&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!-- 3.指定通信规则和端口 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; &gt;&lt;/dubbo:protocol&gt; &lt;!-- 4.1声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;service.UserService&quot; ref=&quot;userServiceImpl&quot; &gt;&lt;/dubbo:service&gt; &lt;!-- 4.2 服务的实现 --&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.dubbo.gmall.service.impl.UserServiceImpl&quot; &gt;&lt;/bean&gt;&lt;/beans&gt; 消费者去注册中心订阅服务提供者的服务地址//二者建立连接 消费者pom.xml引入dubbo,引入zk客户端（同提供者） 配置消费者consumer.xml 设置包扫描路径 12345678&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;&lt;dubbo:application name=&quot;order-service-consumer&quot; &gt;&lt;/dubbo:application&gt;&lt;!-- 使用zk注册中心暴露发现服务地址 --&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; &gt;&lt;/dubbo:registry&gt;&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; &gt;&lt;/dubbo:reference&gt; 1&lt;context:component-scan base-package=&quot;com.dubbo.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt; 连接监控中心 1234&lt;!-- 连接监控中心--&gt;&lt;!-- &lt;dubbo:monitor protocol=&quot;registry&quot; &gt;&lt;/dubbo:monitor&gt; 自适应address--&gt; &lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt; Spring Boot实现 导入依赖 导入dubbo-starter 导入dubbo的其他依赖 接口实现，消费者的控制类实现(控制类实现调用服务提供者的服务) @Service注解import com.alibaba.dubbo.config.annotation.Service注明服务提供者 @Reference注明调用提供者的服务并注入，不使用@Autowired 配置文件 application.properties 对应provider.xml 和consumer.xml 相应标签的值 provider和consumer中使用的端口要不一样，否则报错 若consumer端为web项目，需要重设tomcat端口,否则和dubbo-admin冲突server.port=8081 属性配置覆盖策略 优先度：JVM&gt;xml&gt;Properties JVM:虚拟机参数 XML：**.xml文件或application.properties文件 Properties: dubbo.properties文件 配置规则： check启动时检查，消费者启动时检查相应提供者是否已经启动，未启动则报错，默认为true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; check=&quot;false&quot;&gt;&lt;/dubbo:reference&gt;````* `&lt;dubbo:consumer: ....&gt;`配置当前消费者的统一规则`&lt;dubbo:consumer: check=&quot;false&quot;&gt;&lt;/dubbo:consumer&gt;`* `&lt;dubbo:registry: check=&quot;false&quot;&gt;`注册中心启动时检查* `timeout`指定超时属性，超过timeout时间无返回则报错，默认为1000(ms) * 方法级优先，接口级次之，全局配置再次之 * 如果级别一样，则消费方优先，提供方次之* `retries=&quot;&quot;`重试次数，不包括第一次，第一次失败，再尝试retries次 * 第二次尝试会再试第一次的提供方服务器 * 第三次开始可能会更换别的服务器尝试连接## 多版本`version``version=&quot;*&quot;`随机版本运行## 本地存根在调用提供者服务之前，先验证参数符合要求才调用服务1. 创建Stub类实现要调用的接口，并在重写函数是添加判断2. xml配置,stub=&quot;&quot;```javapublic class UserServiceStub implements UserService &#123; private final UserService userService; /** * 传入userService的远程代理对象 * @param userService */ public UserServiceStub(UserService userService) &#123; super(); this.userService = userService; &#125; /*** * 本地存根 * @param userId * @return */ public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println(&quot;UserServiceStub......&quot;); if(StringUtils.isEmpty(userId))&#123; return userService.getUserAddressList(userId); &#125; return null; &#125;&#125; 1&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; stub=&quot;com.dubbo.gmall.service.UserServiceStub&quot;&gt;&lt;/dubbo:reference&gt; 效果： SpringBoot与dubbo配置整合 导入dubbo-starter,在application.properties中配置属性，使用@Service暴露服务，@Reference引用服务 保留dubbo的xml配置文件 相应就可以删除MainApplication中的EnableDubbo，改为@ImportResource(locations=&quot;classpath：**&#123;url&#125;**&quot;) 去掉@Service和@Reference注解 使用API配置类配置 将每一个组件手动创建到容器中 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyDubboConfig &#123; @Bean public ApplicationConfig applicationConfig()&#123; ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(&quot;boot-user-service-provider&quot;); return applicationConfig; &#125; @Bean public RegistryConfig registryConfig()&#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(&quot;127.0.0.1:2181&quot;); registryConfig.setProtocol(&quot;zookeeper&quot;); return registryConfig; &#125; @Bean public ProtocolConfig protocolConfig()&#123; ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(&quot;dubbo&quot;); protocolConfig.setPort(20880); return protocolConfig; &#125; @Bean public ServiceConfig&lt;UserService&gt; userServiceServiceConfig(UserService userService)&#123; ServiceConfig&lt;UserService&gt; serviceConfig = new ServiceConfig&lt;&gt;(); serviceConfig.setInterface(UserService.class); serviceConfig.setRef(userService); MethodConfig methodConfig = new MethodConfig(); methodConfig.setName(&quot;getUserAddressList&quot;); methodConfig.setTimeout(1000); List&lt;MethodConfig&gt; methods=new ArrayList&lt;&gt;(); methods.add(methodConfig); serviceConfig.setMethods(methods); return serviceConfig; &#125;&#125; 高可用注册机宕机、Dubbo直连注册机宕机后，提供方与消费方可通过本地缓存达成连接 也可以直接使二者直连，而不通过注册机 负载均衡权重、轮询、、、 服务降级mock=force:return+null：调用即返回空，控制台控制“屏蔽” mock=fall:return+null：调用失败则返回空，不抛出异常，控制台“容错” 集群容错默认Failover Cluster，失败自动切换模式 Hystrix容错整合 代码阅读笔记transient将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化","categories":[],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://akatsugi007.com/tags/dubbo/"}]},{"title":"Docker","slug":"Docker/学习","date":"2021-11-07T11:19:53.955Z","updated":"2021-11-07T13:33:47.420Z","comments":true,"path":"2021/11/07/Docker/学习/","link":"","permalink":"https://akatsugi007.com/2021/11/07/Docker/%E5%AD%A6%E4%B9%A0/","excerpt":"DockerDocker 学习过程 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker 以上完成“单机Docker” Docker Compose 集群 Docker Swarm 集群管理 CI \\CD Jenkins 持续集成和持续部署","text":"DockerDocker 学习过程 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker 以上完成“单机Docker” Docker Compose 集群 Docker Swarm 集群管理 CI \\CD Jenkins 持续集成和持续部署 Docker概述Docker 为什么会出现开发与上线 开发与运维 版本更新 –&gt;服务不可用 ==&gt;解决环境配置很麻烦的问题 –&gt;发布项目：jar包+环境一起打包 传统由开发完成jar，运维配置环境 现在由开发打包部署上线，直接完成环境配置 –镜像 仓库地址 https://hub.docker.com/ 文档地址：https://docs.docker.com/ Docker应用场景容器化技术 打包镜像发布测试，一键运行 更便捷的升级和扩缩容 更简单的系统运维：使开发测试环境高度一致 更高效的计算资源利用：Docker是内核级别的虚拟化，可以在一个物理机上运行更多的容器实例 Docker安装Docker的基本组成 名词解释： 安装Docker","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://akatsugi007.com/tags/Docker/"}]},{"title":"自定义注解","slug":"自定义注解","date":"2021-11-07T11:19:53.909Z","updated":"2021-11-07T13:35:30.601Z","comments":true,"path":"2021/11/07/自定义注解/","link":"","permalink":"https://akatsugi007.com/2021/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/","excerpt":"注解类123456@Target(ElementType.METHOD) //作用于方法@Retention(RetentionPolicy.RUNTIME) // 运行时有效@Documented //被 javadoc工具记录@Inherited //可继承public @interface BatchQuery &#123;&#125;","text":"注解类123456@Target(ElementType.METHOD) //作用于方法@Retention(RetentionPolicy.RUNTIME) // 运行时有效@Documented //被 javadoc工具记录@Inherited //可继承public @interface BatchQuery &#123;&#125; 自定义注解@interface 在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口 1234@Aspect //标注增强处理类（切面类）@Component //交由Spring容器管理public @interface CherryAnnotation &#123;&#125; @pointcut注解Pointcut(切入点)： JoinPoint的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发，在程序中主要体现为书写切入点表达式。 1@Pointcut(&quot;@annotation(com.ztesoft.zsmart.pot.annotation.BatchQuery)&quot;) @Around注解@Around注解：可以用来在调用一个具体方法前和调用后来完成一些具体的任务。 =@Before+@After 1234@Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; .... &#125; 也可以不使用@pointcut 123456789101112131415161718//调用controller包下的任意类的任意方法时均会调用此方法@Around(&quot;execution(* com.company.controller.*.*(..))&quot;)public Object run1(ProceedingJoinPoint joinPoint) throws Throwable &#123; //获取方法参数值数组 Object[] args = joinPoint.getArgs(); //得到其方法签名 MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); //获取方法参数类型数组 Class[] paramTypeArray = methodSignature.getParameterTypes(); ....... logger.info(&quot;请求参数为&#123;&#125;&quot;,args); //动态修改其参数 //注意，如果调用joinPoint.proceed()方法，则修改的参数值不会生效，必须调用joinPoint.proceed(Object[] args) Object result = joinPoint.proceed(args); logger.info(&quot;响应结果为&#123;&#125;&quot;,result); //如果这里不返回result，则目标对象实际返回值会被置为null return result; &#125; 如果我们还想利用其进行参数的修改，则调用时必须用joinPoint.proceed(Object[] args)方法，将修改后的参数进行回传。如果用joinPoint.proceed()方法，则修改后的参数并不会真正被使用。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://akatsugi007.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"个人博客搭建","slug":"个人博客搭建","date":"2021-11-07T10:26:21.000Z","updated":"2021-11-07T13:35:31.312Z","comments":true,"path":"2021/11/07/个人博客搭建/","link":"","permalink":"https://akatsugi007.com/2021/11/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"安装Nodejsnode -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本","text":"安装Nodejsnode -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本 mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n 我的第一篇文章 #创建新的文章 返回blog目录hexo clean #清理hexo g #生成 Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件配置_config.yml DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master hexo d #部署到Github仓库里https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 修改hexo根目录下的 _config.yml 文件 ： theme: yiliahexo c #清理一下hexo g #生成hexo d #部署到远程Github仓库https://YourGithubName.github.io/ 查看博客","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://akatsugi007.com/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"Hello World,Hexo","slug":"Hexo","date":"2021-11-07T10:25:01.681Z","updated":"2021-11-07T13:35:28.779Z","comments":true,"path":"2021/11/07/Hexo/","link":"","permalink":"https://akatsugi007.com/2021/11/07/Hexo/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://akatsugi007.com/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://akatsugi007.com/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"https://akatsugi007.com/tags/Redis/"},{"name":"dubbo","slug":"dubbo","permalink":"https://akatsugi007.com/tags/dubbo/"},{"name":"Docker","slug":"Docker","permalink":"https://akatsugi007.com/tags/Docker/"},{"name":"其他","slug":"其他","permalink":"https://akatsugi007.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"实践","slug":"实践","permalink":"https://akatsugi007.com/tags/%E5%AE%9E%E8%B7%B5/"}]}