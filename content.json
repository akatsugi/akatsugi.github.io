{"meta":{"title":"akatsugi","subtitle":"呜啦啦啦","description":null,"author":"akatsugi","url":"https://akatsugi.github.io","root":"/"},"pages":[{"title":"标签","date":"2021-11-07T13:29:16.000Z","updated":"2021-11-07T13:48:47.516Z","comments":true,"path":"tags/index.html","permalink":"https://akatsugi.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-07T13:12:09.000Z","updated":"2021-11-07T13:12:33.887Z","comments":true,"path":"about/index.html","permalink":"https://akatsugi.github.io/about/index.html","excerpt":"","text":"阿巴阿巴"}],"posts":[{"title":"Docker","slug":"Docker/Docker","date":"2021-11-16T10:19:11.000Z","updated":"2021-11-16T10:22:27.619Z","comments":true,"path":"2021/11/16/Docker/Docker/","link":"","permalink":"https://akatsugi.github.io/2021/11/16/Docker/Docker/","excerpt":"DockerDocker 学习过程 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker 以上完成“单机Docker” Docker Compose 集群 Docker Swarm 集群管理 CI \\CD Jenkins 持续集成和持续部署","text":"DockerDocker 学习过程 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker 以上完成“单机Docker” Docker Compose 集群 Docker Swarm 集群管理 CI \\CD Jenkins 持续集成和持续部署 Docker概述Docker 为什么会出现开发与上线 开发与运维 版本更新 –&gt;服务不可用 ==&gt;解决环境配置很麻烦的问题 –&gt;发布项目：jar包+环境一起打包 传统由开发完成jar，运维配置环境 现在由开发打包部署上线，直接完成环境配置 –镜像 仓库地址 https://hub.docker.com/ 文档地址：https://docs.docker.com/ Docker应用场景容器化技术 打包镜像发布测试，一键运行 更便捷的升级和扩缩容 更简单的系统运维：使开发测试环境高度一致 更高效的计算资源利用：Docker是内核级别的虚拟化，可以在一个物理机上运行更多的容器实例 Docker安装Docker的基本组成 名词解释： 安装Docker 安装准备环境 yum -y install 包名 gcc:yum -y install gcc gcc-c++yum -y install gcc-c++ 清除旧版本 1234567891011yum -y remove docker docker-common docker-selinux docker-engineyum removedocker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine 安装yum-utils软件包sudo yum install -y yum-utils 设置镜像仓库 ```bashsudo yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo123456789101112131415161718192021222324252627282930313233343536373839404142434445468. 更新yum软件包索引`yum makecache fast`9. 安装docker`sudo yum install docer-ce docker-ce-cli`10. 启动docker`sudo systemctl start docker`11. 使用`docker version`判断是否安装成功12. ![](https://ftp.bmp.ovh/imgs/2021/11/498b6c897ca92ddf.png)13. HelloWorld测试14. ![](https://ftp.bmp.ovh/imgs/2021/11/94df31373b1f0261.png)[官方文档](https://https://docs.docker.com/engine/install/centos/)#### 配置阿里云镜像加速![](https://ftp.bmp.ovh/imgs/2021/11/efca611a0c3db03d.png)![](https://ftp.bmp.ovh/imgs/2021/11/fa2e438b4a0065b1.png)### Docker![](https://ftp.bmp.ovh/imgs/2021/11/17b0e023f633dd89.png)![](https://files.catbox.moe/e17i4h.png)### 底层原理Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socker从客户端访问！Docker Server接收到Docker-Client的指令，就会执行这个指令![](https://files.catbox.moe/54p3f3.png)#### Docker比VM快1. Docker比虚拟机更少的抽象层2. docker利用宿主机的内核，VM需要的是Guest OS![](https://files.catbox.moe/l3h8ho.png)Docker新建一个容器的时候，不需要像虚拟机一样重新加载一个操作系统内核，直接利用宿主机的操作系统，而虚拟机是需要加载Guest OS。![](https://files.catbox.moe/i13jf1.png)## Docker常用命令### 帮助命令```bashdocker version #查看docker的版本信息docker info #查看docker的系统信息,包括镜像和容器的数量docker 命令 --help #帮助命令(可查看可选的参数)docker COMMAND --help 帮助文档 镜像命令docker images 1234567891011121314151617#解释:1.REPOSITORY 镜像的仓库源2.TAG 镜像的标签3.IMAGE ID 镜像的id4.CREATED 镜像的创建时间5.SIZE 镜像的大小# 可选参数-a/--all 列出所有镜像-q/--quiet 只显示镜像的id docker search搜索镜像 123456789#可选参数 docker search --helpSearch the Docker Hub for imagesOptions: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output docker pull下载镜像 分层下载重复的不会多次下载 docker rmi删除镜像 docker rmi -f Id1 Id2 Id3 docker rmi -f $(docker images -aq)删除全部 容器命令有了镜像才能创建容器 docker pull centos 运行容器12345678910111213docker run [可选参数] image#参数说明--name=&quot;名字&quot; 指定容器名字 tomcat01 tomcat02///-d 后台方式运行-it 使用交互方式运行,进入容器查看内容-p 指定容器的端口(-p ip:主机端口:容器端口 配置主机端口映射到容器端口 常用-p 主机端口:容器端口 常用-p 容器端口)-P 随机指定端口(大写的P) 启动并进入容器 进入后主机名即镜像名（镜像ID） 容器内即一个小型的主机 查看所有运行的容器12345#docker ps # 列出当前正在运行的容器-a # 列出所有容器的运行记录-n=? # 显示最近创建的n个容器-q # 只显示容器的编号 退出容器exit 直接停止并退出容器ctrl + P + Q 容器不停止，退出 删除容器docekr rm 容器id 删除指定容器|不能删除正在运行的容器，强制删除用rm -fdocker rm -f $(docker ps -aq) 删除所有容器docker ps -a -q|xargs docker rm #管道删除所有容器 启动和停止容器1234docker start 容器id # 启动docker restart 容器id # 重启docker stop 容器id # 停止docker kill 容器id # 强制停止 其他常用命令后台启动docker run -d 镜像名docker容器后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止，因此使用docker ps查询发现centos停止了 查看日志命令docker logs 12345678910111213141516docker logs --helpUsage: docker logs [OPTIONS] CONTAINERFetch the logs of a containerOptions: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes) -n, --tail string Number of lines to show from the end of the logs (default &quot;all&quot;) -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)常用：docker logs -tf 容器iddocker logs --tail number 容器id #num为要显示的日志条数 查看容器中的进程信息top命令 查看镜像的元数据docker inspect 容器id 进入正在运行的容器docker exec -it 容器id bashShell 通过exec进入容器后打开一个新的终端，可以在里面操作 docker attach 容器id通过attach进入的正在执行的代码，不会启动新的进程 从容器内拷贝文件到主机上docker cp 容器id:容器内路径 目的的主机路径 小结 练习部署Niginx部署Tomcatdocker run -it --rm tomcat:9.0 --rm 用于测试用完即删 重新使用pull下载tomcat 后台运行 外网访问 进入tomcat01查看 可发现：Tomcat中命令不全，且webapps中为空 原因：阿里云镜像中，默认是最小的镜像，将所有不必要的东西都剔除掉了，从而保证最小的可运行环境 解决： 可以发现，ROOT等文件都放在了webapps.dist中，将其复制到webapps中去即可 cp -r webapps.dist/* webapps 部署ES+KibanaPortainier可视化面版更好的选择：Rancher（CI/CD用） 12docker run -d -p 8088:9000\\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 开通8088端口 Docker镜像什么是镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 Docker镜像加载原理Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionFS联合文件系统。 分层 docker inspect redis:latest Docker镜像默认都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部 这一层就是我们通常说的容器，容器之下为镜像层 commit镜像1234docker commit #提交容器成为一个新的副本#类似gitdocker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[版本] 测试 docker的tomcat默认镜像中是没有webapps的，要想打开8080端口有实际网页，需要将webapps.dist里的文件拷贝到webapps里（见前tomcat部署） 提交后的的镜像就是自行修改后的镜像 类似虚拟机的快照 容器数据卷将Docker容器中MySQL的数据存储同步在本地，数据持久化 将容器内的目录挂载到Linux上 容器的持久化和同步操作，容器间的数据共享 使用数据卷使用命令挂载docker run -it -v 主机目录:容器内目录 镜像名 bashShell 挂载inspect Source与Destination之间为双向绑定 停止容器后，修改主机中的文件，容器内对应文件也会修改 应用：在修改如配置文件之类的文件时，只需要在本地修改即可，容器内可自动同步 安装MySQL问题：MySQL的数据持久化问题 data目录 123456789101112# 获取MySQL镜像docker pull mysql:5.7# 运行容器，挂载数据# 安装启动mysql需要设置密码# -d后台运行 -p端口映射docker run -d -p 3310:3306 -v /home/akatsugi/mysql/conf:/etc/mysql/conf.d -v /home/akatsugi/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 本地连接测试： 本地文件 create database testDockerMysql本地文件会同步更新 删除容器后，本地文件并不会同步删除，以此实现容器的数据持久化功能 具名挂载和匿名挂载docker volume命令 123456789101112131415[root@Akatsugi mysql]# docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumesRun &#x27;docker volume COMMAND --help&#x27; for more information on a command. 匿名挂载 12345678910111213[root@Akatsugi mysql]# docker run -d -P --name centos01 -v /home/akatsugi/test centos1d5389e9df68bc24864f42e0796972881b3fbaccd8a83ded93fd0f20199fdd19[root@Akatsugi mysql]# docker volume lsDRIVER VOLUME NAMElocal 7ec078397ab1ac5f3fa6a81c57bc11442fff2d5cac3968a0894d1a125cd272b9local 09d0712749b3c992f8b93f8860bf27604ccd33bf5315175e434097d0e0899150local 85eec5e4494d26ef191071ac4901b97f2d916905e5cde9c280f334b96010947clocal 39062450a6a4eb89b797ac8e3cc80bf6cef0259a6a268af3fd096266bfd3779clocal e888d2f38dced964541265d34b9edbe067870b092886ad93daa9f37492c5e88dlocal e17283d4352f92930397990e1156fac924dd1c45d6ffad1df4e4692bd60ec26clocal f9118fba608d0ee38ba8fa2884f674faa3e8a7022a1ae22061a949bfab049ca0local ff5a2ec57243c959697442a29e931acba7309fc1ad89990161f7baf24d2e4b1a 具名挂载 123456789[root@Akatsugi mysql]# docker run -d -P --name centos02 -v centosTest:/home/akatsugi/test centosc1cddd3eccd1aebc3781651e4d5146702a436db7b931305478bae59e50f106cf[root@Akatsugi mysql]# docker volume lsDRIVER VOLUME NAME...local 39062450a6a4eb89b797ac8e3cc80bf6cef0259a6a268af3fd096266bfd3779clocal centosTest... 12345678910111213[root@Akatsugi mysql]# docker volume inspect centosTest[ &#123; &quot;CreatedAt&quot;: &quot;2021-11-12T20:38:54+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/www/server/docker/volumes/centosTest/_data&quot;, &quot;Name&quot;: &quot;centosTest&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 读写权限 通过 -v 容器内路径:ro rw 改变读写权限 12docker run -d -P --name centos02 -v centosTest:/home:ro centosdocker run -d -P --name centos02 -v centosTest:/home:rw centos ro 标识的卷只能够通过宿主机来操作，不能在容器内部操作 DockerFile初步DockerFile就是用来构建docker镜像的构建文件，是一个命令脚本 1234567891011121314151617181920212223242526272829303132333435363738394041[root@Akatsugi _data]# docker build --helpUsage: docker build [OPTIONS] PATH | URL | -Build an image from a DockerfileOptions: --add-host list Add a custom host-to-IP mapping (host:ip) --build-arg list Set build-time variables --cache-from strings Images to consider as cache sources --cgroup-parent string Optional parent cgroup for the container --compress Compress the build context using gzip --cpu-period int Limit the CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit the CPU CFS (Completely Fair Scheduler) quota -c, --cpu-shares int CPU shares (relative weight) --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) --disable-content-trust Skip image verification (default true) -f, --file string Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;) --force-rm Always remove intermediate containers --iidfile string Write the image ID to the file --isolation string Container isolation technology --label list Set metadata for an image -m, --memory bytes Memory limit --memory-swap bytes Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap --network string Set the networking mode for the RUN instructions during build (default &quot;default&quot;) --no-cache Do not use cache when building the image --pull Always attempt to pull a newer version of the image -q, --quiet Suppress the build output and print image ID on success --rm Remove intermediate containers after a successful build (default true) --security-opt strings Security options --shm-size bytes Size of /dev/shm -t, --tag list Name and optionally a tag in the &#x27;name:tag&#x27; format --target string Set the target build stage to build. --ulimit ulimit Ulimit options (default [])# -f file 文件# -t target 目标镜像目# . 当前目录docker build -f dockerfile1 -t test/centos . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980[root@Akatsugi docker-test-volume]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd430b6c4a7d1 test/centos &quot;/bin/bash&quot; 39 seconds ago Exited (0) 14 seconds ago wizardly_carson[root@d430b6c4a7d1 /]# cd volume01[root@d430b6c4a7d1 volume01]# touch test.txt[root@d430b6c4a7d1 volume01]# lstest.txt[root@d430b6c4a7d1 volume01]# cd ..[root@d430b6c4a7d1 /]# exitexit[root@Akatsugi docker-test-volume]# vim dockerfile1[root@Akatsugi docker-test-volume]# cat dockerfile1 FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;-----end-----&quot;CMD /bin/bash[root@Akatsugi docker-test-volume]# docker build -f dockerfile1 -t test/centos .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 5d0da3dc9764Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] ---&gt; Running in d296ad8e92deRemoving intermediate container d296ad8e92de ---&gt; 37670011901bStep 3/4 : CMD echo &quot;-----end-----&quot; ---&gt; Running in eae40435b4f9Removing intermediate container eae40435b4f9 ---&gt; 1fad7821ff52Step 4/4 : CMD /bin/bash ---&gt; Running in 5328c36df990Removing intermediate container 5328c36df990 ---&gt; 3a5fb77fa656Successfully built 3a5fb77fa656Successfully tagged test/centos:latest[root@Akatsugi docker-test-volume]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/centos latest 3a5fb77fa656 34 seconds ago 231MB[root@Akatsugi docker-test-volume]# docker run -it test/centos /bin/bash[root@33096ed08d33 /]# lsbin etc lib lost+found mnt proc run srv tmp var volume02dev home lib64 media opt root sbin sys usr volume01^PQ[root@Akatsugi docker-test-volume]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd430b6c4a7d1 test/centos &quot;/bin/bash&quot; 2 minutes ago Up About a minute wizardly_carson[root@Akatsugi docker-test-volume]# docker inspect d430b6c4a7d1...&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;f06e0ee646635f1237758817a917702a81207961855c35a14de6077590480efd&quot;, &quot;Source&quot;: &quot;/www/server/docker/volumes/f06e0ee646635f1237758817a917702a81207961855c35a14de6077590480efd/_data&quot;, &quot;Destination&quot;: &quot;volume01&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125;, &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;458bdc74f166a5064fe9c5583b8a038c78e523b1b3bdf413584f1e39491975ee&quot;, &quot;Source&quot;: &quot;/www/server/docker/volumes/458bdc74f166a5064fe9c5583b8a038c78e523b1b3bdf413584f1e39491975ee/_data&quot;, &quot;Destination&quot;: &quot;volume02&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125; ],...[root@Akatsugi volumes]# cd /www/server/docker/volumes/f06e0ee646635f1237758817a917702a81207961855c35a14de6077590480efd/_data[root@Akatsugi _data]# lstest.txt 123456789# 以centos为基础FROM centos# 挂载卷 匿名挂载VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]# 输出CMD echo &quot;-----end-----&quot;CMD /bin/bash 数据卷容器多个MySQL之间同步容器 创建容器docker01 创建容器docker02 --volumes-from继承数据卷 [root@Akatsugi akatsugi]# docker run -it --name docker02 --volumes-from docker01 test/centos 在docker01的数据卷中创建一个文件 在docker02中可以发现文件得到了同步 创建一个docker03，并在其中touch一个docker03，发现在docker01,02中都可以同步数据 删除docker01和docker02后，docker03中的数据依旧在 多个MySQL123456[root@Akatsugi /]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7[root@Akatsugi /]# docker run -d -p 3311:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7 DockerFileDockerFile介绍用于构建docker镜像的文件，命令参数脚本 步骤: 编写dockerfile文件 docker build构建为镜像 docker run 运行镜像 docker push 发布镜像(发布到DockerHub或阿里云镜像仓库) centos 123456789101112131415FROM scratch # 一个最基础的镜像ADD centos-7-x86_64-docker.tar.xz / # 添加了一个centos7LABEL \\ # centos的基本标签 org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20201113&quot; \\ org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\ org.opencontainers.image.vendor=&quot;CentOS&quot; \\ org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\ org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;CMD [&quot;/bin/bash&quot;] 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 DockerFile的构建过程基础知识 每个保留关键字（指令）都必须是大写字母 执行从上到下执行 # 表示注释 每个指令都会创建提交一个新的镜像层，并提交 dockerfile是面向开发的，以后如果要发布项目，做镜像，就需要编写dockerfile文件 docker镜像已经逐渐成为企业交付的标准 DockerFile: 构建文件，定义了一切的步骤，源代码 DockerImages：通过DockerFile生成的镜像，最终发布和运行的产品 Docker容器：镜像运行起来提供服务 DockerFile指令 指令 用法 FROM 基础镜像，一切都是从这里开始构建 MAINTAINER 镜像作者，一般姓名+邮箱 RUN 镜像构建的时候需要运行的命令 ADD 步骤：tomcat镜像，这个tomcat压缩包，添加内容 WORKDIR 镜像的工作目录 VOLUME 挂载的目录 EXPOSE 保留端口配置 CMD 指定容器启动的时候要运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT 指定容器启动的时候要执行的命令，可以追加命令 ONBUILD 当构建一个被继承DockerFile这个时候才会运行ONBUILD命令 COPY 类似ADD命令，将文件拷贝到镜像中 ENV 构建时设置环境变量 解释：CMD与ENTRYPOINT：若dockerfile中本身有CMD ls -a或ENTRYPOINT ls -a时，若执行docker run -l ,则对于CMD实际只执行 -l,对于ENTRYPOINT会执行ls -a -l 实战测试centosDockerHub中大部分镜像都是从scratch这个基础镜像开始的，FROM scratch 然后配置需要的软件和配置来进行构建 创建一个自己的centos 1234567891011121314151617181920212223[root@Akatsugi dockerFile]# docker run -it mycentos:0.1## 编写DockerFile文件[root@Akatsugi dockerFile]# vim mydockerfile[root@Akatsugi dockerFile]# cat mydockerfile FROM centos #基于centosMAINTAINER akatsugi&lt;akatsugi@qq.com&gt; # 作者ENV MYPATH /usr/local # 设置一个路径 WORKDIR $MYPATH # 设置工作路径RUN yum -y install vim # 按照vim等RUN yum -y install net-toolsEXPOSE 80 # 暴露80端口CMD echo $MYPATHCMD echo &quot;-----end------&quot;CMD /bin/bash# 构建[root@Akatsugi dockerFile]# docker build -f mydockerfile -t mycentos:0.1 .# 测试运行[root@Akatsugi dockerFile]# docker run -it mycentos:0.1 测试：docker images可以找到相应的镜像 运行后直接到设定的工作目录中，ifconfig和vim都能正常使用了 docker history查看镜像的修改历史 CMD和ENTRYPOINT的区别CMD 、 构建并运行：成功执行ls -a 添加”-l”后执行，ls -a失效，只剩下l ENTRYPOINT 同样的操作，entrypoint时，运行镜像添加命令参数，原指令可以执行 实战测试tomcat 准备tomcat压缩包，jdk压缩包 编写dockerfile文件，官方命名为Dockerfile,build会自动寻找此文件，就不需要再-f来指定了 123456789101112131415161718192021222324FROM centosMAINTAINER akatsugi&lt;akatsugi@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u202-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.54.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATH# 环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_202ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.54ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.54ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.54/bin/startup.sh &amp;&amp; tail -F /url/local/apache-tomcat-9.0.54/bin/logs/catalina.out 构建镜像 docker build -t mytomcat . 运行镜像 挂载了日志文件和webapps/test文件 1[root@Akatsugi tomcat]# docker run -d -p 3355:8080 --name atomcat -v /home/akatsugi/tomcat/test:/usr/local/apache-tomcat-9.0.54/webapps/test -v /home/akatsugi/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.54/logs mytomcat 访问测试 localhost:3355 ip:3355 发布项目 进行卷挂载，使可以在本地编写项目发布 本地test文件夹下编写web.xml和index.jsp 访问ip:3355/test 查看本地tomcatLogs下的Catalina.out可查看日志 web.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt;&lt;/web-app&gt; index.jsp 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;tomcatTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello DockerTomcat!&lt;br/&gt;&lt;%System.out.println(&quot;------my test web logs----&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; 发布自己的镜像发布到DockerHub123456789101112[root@Akatsugi tomcat]# docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 注册DockerHub账号 修改镜像的tag：docker tag 镜像id 你的账户名/镜像仓库名:tag名 提交：docker push 你的账户名/镜像仓库名:tag名 发布到阿里云镜像服务 登录阿里云-容器镜像服务 创建命名空间 创建镜像仓库（本地） 操作 Docker 流程 save/load:将镜像打包成tar压缩包，以发送给别 12345678910111213141516171819[root@Akatsugi tomcat]# docker save --helpUsage: docker save [OPTIONS] IMAGE [IMAGE...]Save one or more images to a tar archive (streamed to STDOUT by default)Options: -o, --output string Write to a file, instead of STDOUT[root@Akatsugi tomcat]# docker load --helpUsage: docker load [OPTIONS]Load an image from a tar archive or STDINOptions: -i, --input string Read from tar archive file, instead of STDIN -q, --quiet Suppress the load output Docker网络（容器编排，集群部署，流水线）Docker0（先清空所有镜像 ip addr 查询得有3个网卡 运行docker tomcat镜像，查看ip，有两个网卡 使用本机(linux)可以ping到容器内部 —-&gt;Linux可以ping通docker容器内部 每启动一个docker容器，docker就会给容器分配一个ip，只要安装了docker，电脑就会有一个网卡docker0(桥接模式)，使用了evth-pair技术 本机在ip addr得到以下 启动一个新的容器,可以发现主机又多了一对网卡（100，101为一对） evth-pair 就是要一对的虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 evth-pair就充当一个桥梁，连接各种虚拟设备 OpenStack，Docker容器之间的连接，都说使用evth-pair技术 容器之间互ping，能ping通 所有容器不指定网络的情况下都说docker0路由的，docker会给容器分配一个默认的可用IP Docker中的所有网络接口都说虚拟的（虚拟的转发效率高 –link12root@f77ae4ee2395:/usr/local/tomcat# ping tomcat01ping: tomcat01: Name or service not known 使能ping通 反向ping不通 自定义网络查看所有docker网络 docker network ls 1234567891011121314151617[root@Akatsugi ~]# docker network --helpUsage: docker network COMMANDManage networksCommands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networksRun &#x27;docker network COMMAND --help&#x27; for more information on a command. 网络模式bridge:桥接（默认） host:和宿主机共享网络 none:不配置网络 container：容器网络连通（让容器之间直接互联，局限大，用得少） 测试12docker run -d -P --name tomcat01 --net bridge tomcat默认即为桥接模式 1234567891011# 创建网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet# 查看docker network lsdocker network inspect mynet# 启动容器docker run -d -P --name tomcat01 --net mynet tomcat 同一自定义网络下的两个容器可以不用–link就使用容器名来ping通 网络连通 显然不行，因此需要使tomcat-02连通Mynet,从而ping通tomcat-net-01 12345678910111213[root@Akatsugi ~]# docker network connect --helpUsage: docker network connect [OPTIONS] NETWORK CONTAINERConnect a container to a networkOptions: --alias strings Add network-scoped alias for the container --driver-opt strings driver options for the network --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --link list Add link to another container --link-local-ip strings Add a link-local address for the container 1234docker network connect mynet tomcat-01# 连通之后docker network inspect mynet# 发现实际是把tomcat-01放到了mynet网络下，即一个容器有了两个ip 实战 Redis集群部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# 创建网络[root@Akatsugi ~]# docker network create redis --subnet 172.38.0.0/16# 创建6个redis配置for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0Cluster-enabled yesCluster-config-file nodes.confCluster-node-timeout 5000Cluster-announce-ip 172.38.0.1$&#123;port&#125;Cluster-announce-port 6379Cluster-announce-bus-port 16379appendonly yesEOFdone# 启动容器docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\-v /mydata/redis/node-1/data:/data \\-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.11 redis redis-server /etc/redis/redis.confdocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\-v /mydata/redis/node-2/data:/data \\-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.12 redis redis-server /etc/redis/redis.confdocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\-v /mydata/redis/node-3/data:/data \\-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.13 redis redis-server /etc/redis/redis.confdocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\-v /mydata/redis/node-4/data:/data \\-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.14 redis redis-server /etc/redis/redis.confdocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\-v /mydata/redis/node-5/data:/data \\-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.15 redis redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis redis-server /etc/redis/redis.conf# 进入redis-1docker run -it redis-1 /bin/sh# 创建集群redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 172.38.0.15:6379 to 172.38.0.11:6379Adding replica 172.38.0.16:6379 to 172.38.0.12:6379Adding replica 172.38.0.14:6379 to 172.38.0.13:6379M: 5afdf284a13a04ea023fb3c7a464994a1d5595bb 172.38.0.11:6379 slots:[0-5460] (5461 slots) masterM: b85b56c965dc459411d3ef38b65fae4912d859e8 172.38.0.12:6379 slots:[5461-10922] (5462 slots) masterM: 9e7997dbdb938f3344657a4673e01d4bb90aaf7c 172.38.0.13:6379 slots:[10923-16383] (5461 slots) masterS: 19433ea8c90083d00e82ef0152ce9257d5f550ad 172.38.0.14:6379 replicates 9e7997dbdb938f3344657a4673e01d4bb90aaf7cS: 1ee5cd151ec8c2f198a53ea7d5c3ffeb79556c7f 172.38.0.15:6379 replicates 5afdf284a13a04ea023fb3c7a464994a1d5595bbS: 191d6f85e19c5d0552e7f9f5e0e49fc0922f0717 172.38.0.16:6379 replicates b85b56c965dc459411d3ef38b65fae4912d859e8Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.&gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)M: 5afdf284a13a04ea023fb3c7a464994a1d5595bb 172.38.0.11:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)S: 1ee5cd151ec8c2f198a53ea7d5c3ffeb79556c7f 172.38.0.15:6379 slots: (0 slots) slave replicates 5afdf284a13a04ea023fb3c7a464994a1d5595bbS: 191d6f85e19c5d0552e7f9f5e0e49fc0922f0717 172.38.0.16:6379 slots: (0 slots) slave replicates b85b56c965dc459411d3ef38b65fae4912d859e8M: b85b56c965dc459411d3ef38b65fae4912d859e8 172.38.0.12:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: 19433ea8c90083d00e82ef0152ce9257d5f550ad 172.38.0.14:6379 slots: (0 slots) slave replicates 9e7997dbdb938f3344657a4673e01d4bb90aaf7cM: 9e7997dbdb938f3344657a4673e01d4bb90aaf7c 172.38.0.13:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. redis集群 stop掉redis-3 SpringBoot微服务打包Docker镜像 编写SpringBoot微服务 package成jar IDEA按照docker插件 编写Dockerfile 将jar包和dockerfile传到服务器 服务器使用docker build构建镜像 运行 12345678910# DockerfileFROM java:8COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@Akatsugi idea]# docker build -t demo .Sending build context to Docker daemon 17.49MBStep 1/5 : FROM java:88: Pulling from library/java5040bd298390: Pull complete fce5728aad85: Pull complete 76610ec20bf5: Pull complete 60170fec2151: Pull complete e98f73de8f0d: Pull complete 11f7af24ed9c: Pull complete 49e2d6393f32: Pull complete bb9cdec9c7f3: Pull complete Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9dStatus: Downloaded newer image for java:8 ---&gt; d23bdf5b1b1bStep 2/5 : COPY *.jar /app.jar ---&gt; 6e2d65f0fe28Step 3/5 : CMD [&quot;--server.port=8080&quot;] ---&gt; Running in b68a5ffa8d3eRemoving intermediate container b68a5ffa8d3e ---&gt; d72768fef782Step 4/5 : EXPOSE 8080 ---&gt; Running in 7c39d69f0f59Removing intermediate container 7c39d69f0f59 ---&gt; 14773ba2e7c6Step 5/5 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] ---&gt; Running in c8536147c226Removing intermediate container c8536147c226 ---&gt; ce5731399e40Successfully built ce5731399e40Successfully tagged demo:latest--------------------------------------------------------------------------------------------------------------------------------------[root@Akatsugi idea]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdemo latest ce5731399e40 6 seconds ago 661MBtomcat latest b0e0b0a92cf9 3 weeks ago 680MBredis latest 7faaec683238 5 weeks ago 113MBjava 8 d23bdf5b1b1b 4 years ago 643MB[root@Akatsugi idea]# docker run -d -P --name demo01 demo4eed7271bb5f7fd9f3d9310f0a22d07c106ccae3af3d26cf1a7c4b6224529922[root@Akatsugi idea]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4eed7271bb5f demo &quot;java -jar /app.jar …&quot; 17 seconds ago Up 15 seconds 0.0.0.0:49160-&gt;8080/tcp, :::49160-&gt;8080/tcp demo01------------------------------------------------------------------------------------------------------------------------------------------[root@Akatsugi idea]# curl localhost:49160&#123;&quot;timestamp&quot;:&quot;2021-11-16T10:12:14.658+00:00&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;path&quot;:&quot;/&quot;&#125;[root@Akatsugi idea]# curl localhost:49160/hellohello,springboot[root@Akatsugi idea]#","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://akatsugi.github.io/tags/Docker/"}]},{"title":"个人服务器搭建","slug":"服务器搭建","date":"2021-11-09T05:39:22.851Z","updated":"2021-11-09T09:41:07.592Z","comments":true,"path":"2021/11/09/服务器搭建/","link":"","permalink":"https://akatsugi.github.io/2021/11/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"阿里云购买服务器安全组设置Linux防火墙的端口开完后，一定还需要在阿里云设置安全组规则，开放端口号，否则外部无法访问 远程登录","text":"阿里云购买服务器安全组设置Linux防火墙的端口开完后，一定还需要在阿里云设置安全组规则，开放端口号，否则外部无法访问 远程登录 获取公网IP：我的： (公) 120.76.216.104 (内) 172.22.59.212 修改自己的登录密码 下载Xshell远程连接工具，XFTP文件上传 上传文件使用xftp Linux系统目录结构一切皆文件 根目录/ /bin Binary，存放常使用的命令 /boot 存放Linux的核心文件（链接文件和镜像文件） /dev Device /etc 存放系统管理所需要的配置文件和子目录 Redis配置等 /home 用户目录的主目录 /lib 存放系统最基本的动态共享库类似dll文件 /lost+found 一般为空，当系统非法关机后，存放一些文件 /media U盘，光驱等设备，识别后会挂载在此目录下 /mnt 让用户临时挂载别的文件系统 /opt 给主机额外安装软件所摆放的目录 按照MySQL，Redis等等 /proc 系统内存的映射，可通过此目录获取系统信息 /root 系统管理员 /sbin s==SuperUser 存放系统管理员使用的系统管理程序 /srv 存放一些服务启动后需要提取的数据 /tmp 存放临时文件 /usr 用户程序和文件都存放在此 /usr/bin 系统用户使用的应用程序 /usr/sbin 超级用户使用的 /usr/src 内核源代码 /var 存放一些不断扩充的东西， 习惯将那些经常修改的目录放在此，如日志文件 /run 临时文件系统 存储系统启动以来的信息 环境安装rpm（jdk） jdk的rpm包 安装java环境 检查java环境 rpm -ivh rpm包 配置环境变量 rpm安装不需要配置环境变量 卸载 rpm -qa|grep jdk rpm -e --nodeps jdk****** 解压缩(tomcat) tar.gz 解压tar -zxvf ******.tar.gz 启动Tomcat测试 ./xx.sh脚本执行 防火墙打开8080端口 yum在线安装(docker) 安装准备环境 yum -y install 包名 gcc:yum -y install gcc gcc-c++yum -y install gcc-c++ 清除旧版本 1234567891011yum -y remove docker docker-common docker-selinux docker-engineyum removedocker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine 安装yum-utils软件包sudo yum install -y yum-utils 设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 更新yum软件包索引yum makecache fast 安装dockersudo yum install docer-ce docker-ce-cli 启动dockersudo systemctl start docker 使用docker version判断是否安装成功 HelloWorld测试 官方文档 配置阿里云镜像加速","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://akatsugi.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"Spring Security","slug":"SpringSecurity/SpringSecurity","date":"2021-11-07T12:12:51.033Z","updated":"2021-11-07T13:35:33.323Z","comments":true,"path":"2021/11/07/SpringSecurity/SpringSecurity/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/SpringSecurity/SpringSecurity/","excerpt":"SpringSecurityCSDN实例 基本原理SpringSecurity本质是一个过滤器链","text":"SpringSecurityCSDN实例 基本原理SpringSecurity本质是一个过滤器链 FilterSecurityInterceptor：方法级的权限过滤器，基本位于过滤链的最底部 ExceptionTranslationFilter:异常过滤器，用来处理再认证授权过程中抛出的异常 这两个Filter通常是结合在一起用的，前者负责处理后者所抛出的异常并做相应的处理，后者主要用于鉴权。ExceptionTranslationFilter在处理异常时，如果异常为AuthenticationException类型，表示用户认证都失败了(比如还没有经过认证)，此时将调用AuthenticationEntryPoint开启认证过程，比如向用户展示登录页面；如果异常为AccessDeniedException，表示用户可能已经登录但是没有足够的权限，此时将调用AccessDeniedHandler，比如向用户展示“你没有权限”的通知页面。 UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中用户名密码 用于处理基于Form登录的认证，认证成功重定向到指定页面，认证失败向用户重新返回登录界面并提示错误。UsernamePasswordAuthenticationFilter继承自AbstractAuthenticationProcessingFilter，AbstractAuthenticationProcessingFilter可以配置一个AuthenticationSuccessHandler和一个AuthenticationFailureHandler，认证成功之后将调用AuthenticationSuccessHandler，比如像UsernamePasswordAuthenticationFilter一样重定向到某个页面，也可以根据自定义向用户返回一个JWT的Token；认证失败(比如用户名或密码不正确)后将调用AuthenticationFailureHandler，比如像UsernamePasswordAuthenticationFilter一样重新返回登录页面，也可以根据自定义向用户返回一个401状态码。 AbstractAuthenticationProcessingFilter并不完成认证逻辑，而是将其交给AuthenticationManager，AuthenticationManager进而代理给AuthenticationProvider，AuthenticationProvider验证用户提供的凭证是否正确(比如从数据库加载用户的密码然后与用户提供的密码对比，或者与LDAP服务器通信验证用户名和密码)。 过滤器加载 使用SpringSecurity配置过滤器 DelegatingFilterProxy UserDetailsService接口自定义账号密码逻辑，数据库？内存？ （redis? 查询数据库用户名和密码的过程 创建类继承UsernamePasswordAuthenticationFilter，重写其中三个方法 attemptAuthentication 判断用户名密码 successfulAuthentication 成功 unsuccessfulAuthentication 失败 创建类实现UserDetailsService接口，编写查询数据过程，返回User对象（User对象是安全框架提供的对象） PasswordEncoder对密码加密接口 12BCryptPasswordEncoder bCryptPasswordEncoder =new BCryptPasswordEncoder();String pwd=bCryptPasswordEncoder.encode(&quot;password&quot;); web权限方案认证与授权 设置登录用户名密码 配置文件 application.properties中 spring.security.user.name= spring.security.user.password= 配置类 @Configuration extends WebSecurityConfigurerAdapter 自定义实现类UserDetailsService 创建配置类，设置使用哪个userDetailsService实现类 编写实现类，返回User对象，User对象有用户名密码和操作 数据库 引入依赖 创建数据库 创建实体类Users 创建mapper接口,interface UserMapper ,增删改查函数 mapper.xml文件对应接口的增删改查 (使用MyBatis-Plus可简化45，接口继承BaseMapper&lt;Users&gt;) 在UserDetailsService的自定义实现类中调用mapper中的方法查询数据库对用户的认证信息（根据username查询） 在启动类中添加@MapperScan(“Mapper所在包”)注释 配置文件中配置数据库信息 springBoot2默认使用Mysql8;driver-class-name加cj;设置时区 配置类configure设置自定义登录页面、403页面等 基于角色和权限实现访问控制1. hasAuthority如果当前主体具有指定的权限，有则返回true，否则false 2. hasAnyAuthority 3. hasRole底层代码中将role改为了ROLE_#{role} 4. hasAnyRole同上 注解使用@Secured判断用户是否具有角色（其中匹配的字符串需要加上前缀”ROLE_”) 开启注解功能@EnableGlobalMethodSecurity(securedEnable=true) 在控制器方法上放添加@Secured(&#123;&quot;ROLE_normal&quot;,&quot;ROLE_admin&quot;&#125;) @PreAuthorize在进入方法前进行权限验证 @PreAuthorize(&quot;hasAnyAuthority(&#39;admins&#39;)&quot;)四个方法都可以填在( )里面 开启注解功能@EnableGlobalMethodSecurity(prePostEnabled=true) @PostAuthorize方法执行之后进行权限验证，多用于返回值 开启注解功能@EnableGlobalMethodSecurity(prePostEnabled=true) @PostAuthorize(&quot;hasAnyAuthority(&#39;admins&#39;)&quot;)四个方法都可以填在( )里面 test: ↑有输出但跳转到403页面 @PostFilter不常用 对返回数据进行过滤 @PreFilter不常用 对传入方法的数据进行过滤 用户注销配置类中添加退出配置 http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/index&quot;).permitAll() 退出超链接： &lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt; 基于数据库实现自动登录“自动登录”“十天内免登陆”…. cookie技术 安全框架实现 原理 具体实现 创建数据库 JdbcTokenRepositoryImpl中有建表sql语句 修改配置类：注入数据源，配置操作数据库对象 123456789@Autowiredprivate DataSource dataSource;@Bean public PersistenTokenRepository persistenTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); // jdbcTokenRepository.setCreateTableOnStartup(true) 自动创建数据库表 return jdbcTokenRepository;&#125; 3. 自动登录复选框 1&lt;input type=&quot;checkBox&quot; name=&quot;remeber-me&quot;/&gt; CSRF跨站请求伪造 form中加入以下语句 1&lt;input type=&quot;hidden&quot; th:name=&quot;$&#123;_csrf.parameterName&#125;$&quot; th:value=&quot;$&#123;_csrf.token&#125;$&quot;/&gt; csrfFilter.class 微服务 微服务的每个模块都相当于一个单独的项目，代码量明显减少，遇到的问题也相对来说比较好解决 微服务的每个模块可以使用不同的存储方式(redis/mysql/etc）数据库也是每个模块对应自己的数据库 每个模块可以使用不同的开发技术、开发语言，开发模式更灵活 实例 源码分析 UsernamePasswordAuthenticationFilter 查询Filter父类AbstractAuthenticationProcessingFilter的doFilter() 判断提交方式是否是post提交 调用子类的方法attemptAuthentication(request,response)进行身份验证 认证信息存入Authentication对象中 session策略处理 认证失败抛出异常，执行认证失败的方法unsuccessfulAuthentication() 认证成功执行认证成功的方法 attemptAuthentication(request,response) 判断是否是post提交，不是则抛出异常 获取表单提交的数据 使用获取数据，构造成对象，标记成未认证状态，把请求中的一些属性信息设置到对象里，调用方法进行身份认证(userDetailsService) UsernamePasswordAuthencationToken构建过程","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://akatsugi.github.io/tags/Spring/"}]},{"title":"Redis","slug":"Redis/redis","date":"2021-11-07T11:20:27.189Z","updated":"2021-11-07T13:35:32.628Z","comments":true,"path":"2021/11/07/Redis/redis/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/Redis/redis/","excerpt":"Redis数据类型STRING二进制安全，可以包含任何数据 大小上下512M LIST","text":"Redis数据类型STRING二进制安全，可以包含任何数据 大小上下512M LIST 字符串列表 按照插入顺序排序 头部LEFT 尾部RIGHT HASH类似Java.Map 键值对集合 用于存储对象 SETSTRING 类型的无序集合 内容不重复 ZSETSET+ 每个元素都会关联一个double 类型的分数score score可重复 命令key相关set,del,dump,exists,ttl,expire,persist,pexpire,pttl,keys set：插入记录，返回OK成功，重复插入统一个值显示OK，但只要一条记录 get：获取key中的值，无值返回(nil) del：删除记录，成功显示(interger) 1 dump：序列化给定的key exist：查询给定的Key是否存在，存在返回(interger) 1，否则返回(interger) 0 ttl:查询超时时间 单位s，-1表示key存在且未设置过期时间，-2表示key不存在或已过期 pttl：查询超时时间，单位ms expire:设置过期时间s pexire:设置过去时间ms persisit:移出key的过期时间 keys：查询匹配的所有key STRINGappend,decr,decrby,get,getrange,getset,incr,incrby,incrbyfloat,mget,mset,setex,psetex,setnx,msetnx,setrange,strlen append: decr:+1 decrby: +value get getrange : get start~end getset: get 并set mget,mset：批量get,set setex: set并设置过期时间 psetex setnx:不存在时set,成功返回1，失败（已存在）返回0 msetnx:批量setnx，如果有一个存在，则都不执行 setrange:定位set，已存在点覆盖，无值点’\\x00’ strlen STRING中的BIT1getbit,setbit,bitop,bitcount,bitpos listlpush,lrange,rpush,rpop,lpop,lindex,ltrim,blpop lpush list value： 从左到右，在list的头部插入数据 rpush list value：从左到右，在list的尾部插入数据 lrange list start end:从左到右显示数据 rpop list:弹出list尾部数据 lpop list:弹出list头部数据 lindex list index:显示指定下标的数据 ltrim list start end:修剪list中start~end以外的部分 blpop list timeout : 阻塞式弹出list最左边的数据，若list为空则阻塞timeout秒 set1sadd,srem,sismember,scard,smember,srandmember,spop,smov,sdiff,sdiffstore,sinter,sintersotre,sunion,sunionstore sadd set value:添加 srem set value:删除 sismember set value:判断value是否是set的成员 scard set:set的元素个数 smember set:输出set的元素 srandmember set [count=1]:随机输出count个元素， 0&lt;count&lt;scard ：随机输出count个元素； count&gt;scard：输出scard个元素； -scard&lt;count&lt;0:随机输出count个元素； count&lt;-scard：随机输出count个元素，可重复 sdiff s1 s2:s1-s2差集 … hash1hset,hget,hmset,hmget,hdel,hsetnx,hvals,hkeys,hgetall,hexists,hincrby,hincrbyfloat,hlen,hstrlen zset1zadd,zscore,zrange,zrevrange,zcard,zcount,zrangebyscore,zrank,zrevrank,zincrby,zinterstore,zrem,zlexcount,zrangebylex zadd zset member score [member score …] ：增 zscore zset member:查score zrange zset start end :查 zcard zset zcount zset min max zrank zset member .. zlexcount zset min max:集合中score相同时，字典序下指定成员之间的数量 zrangebylex zset min max：集合中score相同时，字典序下指定成员之间排列 发布订阅subscribe publish 事务MULTI 事务异常WATCH 快照持久化 AOF持久化SpringBoot整合 导入启动器包 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接信息 12345678910111213spring: redis: host: 127.0.0.1 port: 6379 password: 123456 jedis: pool: max-active: 8 max-wait: -1 max-idle: 500 min-idle: 0 lettuce: shutdown-timeout: 0 测试 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class Test_1&#123; @Autowired private RedisTemplate&lt;String,String&gt;redisTemplate; @Test public void set()&#123; redisTemplate.opsForValue().set(&quot;myKey&quot;,&quot;myValue&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;myKey&quot;)); &#125;&#125; 配置序列化器不配置序列化器，运行会显示乱码 CSDN教程 entity 实现序列化接口Serializable 配置类设置序列化器 1234567891011121314@Configurationpublic class RedisConfig&#123; @Bean public RedisTemplate&lt;String, Days&gt;redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Days&gt;template=new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //设置key的序列化器 template.setKeySerializer(new StringRedisSerializer()); //设置value的序列化器 template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Days.class)); return template; &#125;&#125; 测试类: @Autowired 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123; @Autowired private RedisTemplate&lt;String,Days&gt; redisTemplate; private Days d; @Before public void before()&#123; d=new Days(); d.setDate(&quot;123&quot;); d.setDaysId(&quot;456&quot;); d.setItemNumber(123); d.setOpenId(&quot;dawda&quot;); d.setTitle(&quot;title&quot;); &#125; @Test public void testSet()&#123; this.redisTemplate.opsForValue().set(&quot;days&quot;,d); System.out.println((redisTemplate.opsForValue().get(&quot;days&quot;))); &#125;&#125;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://akatsugi.github.io/tags/Redis/"}]},{"title":"Dubbo","slug":"Dubbo/dubbo","date":"2021-11-07T11:19:54.236Z","updated":"2021-11-07T13:35:31.963Z","comments":true,"path":"2021/11/07/Dubbo/dubbo/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/Dubbo/dubbo/","excerpt":"Dubbo设计架构 基本流程： Container 启动服务 Provider将服务注册到注册中心zk中去 Consumer向注册中心订阅服务 Registry向消费者返回响应服务的Provider Consumer向服务提供者调用服务，二者间建立联系，自此可以不再需要Zk Monitor实时监控连接情况、点击次数（没有Monitor也不影响运行）","text":"Dubbo设计架构 基本流程： Container 启动服务 Provider将服务注册到注册中心zk中去 Consumer向注册中心订阅服务 Registry向消费者返回响应服务的Provider Consumer向服务提供者调用服务，二者间建立联系，自此可以不再需要Zk Monitor实时监控连接情况、点击次数（没有Monitor也不影响运行） 注册中心 Zookeeper Dubbo-admin 示例公共接口 提供接口定义和bean类定义实现 导入dubbo 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 服务器提供者 提供服务接口的实现 导入公共接口 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubbo.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 服务消费者 提供消费者接口的实现 导入公共接口 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubbo.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 消费者远程调用提供者的服务步骤： 服务提供者注册到注册中心//暴露服务 pom.xml 引入dubbo依赖、引入ZooKeeper客户端 配置服务提供者provider.xml （spring xml） 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.8&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 1. 指定当前服务/应用的名字，与服务名相同 --&gt; &lt;dubbo:application name=&quot;user-service-gmall&quot; &gt;&lt;/dubbo:application&gt; &lt;!-- 2.使用zookeeper注册中心暴露服务地址 --&gt;&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;--&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!-- 3.指定通信规则和端口 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; &gt;&lt;/dubbo:protocol&gt; &lt;!-- 4.1声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;service.UserService&quot; ref=&quot;userServiceImpl&quot; &gt;&lt;/dubbo:service&gt; &lt;!-- 4.2 服务的实现 --&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.dubbo.gmall.service.impl.UserServiceImpl&quot; &gt;&lt;/bean&gt;&lt;/beans&gt; 消费者去注册中心订阅服务提供者的服务地址//二者建立连接 消费者pom.xml引入dubbo,引入zk客户端（同提供者） 配置消费者consumer.xml 设置包扫描路径 12345678&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;&lt;dubbo:application name=&quot;order-service-consumer&quot; &gt;&lt;/dubbo:application&gt;&lt;!-- 使用zk注册中心暴露发现服务地址 --&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; &gt;&lt;/dubbo:registry&gt;&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; &gt;&lt;/dubbo:reference&gt; 1&lt;context:component-scan base-package=&quot;com.dubbo.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt; 连接监控中心 1234&lt;!-- 连接监控中心--&gt;&lt;!-- &lt;dubbo:monitor protocol=&quot;registry&quot; &gt;&lt;/dubbo:monitor&gt; 自适应address--&gt; &lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt; Spring Boot实现 导入依赖 导入dubbo-starter 导入dubbo的其他依赖 接口实现，消费者的控制类实现(控制类实现调用服务提供者的服务) @Service注解import com.alibaba.dubbo.config.annotation.Service注明服务提供者 @Reference注明调用提供者的服务并注入，不使用@Autowired 配置文件 application.properties 对应provider.xml 和consumer.xml 相应标签的值 provider和consumer中使用的端口要不一样，否则报错 若consumer端为web项目，需要重设tomcat端口,否则和dubbo-admin冲突server.port=8081 属性配置覆盖策略 优先度：JVM&gt;xml&gt;Properties JVM:虚拟机参数 XML：**.xml文件或application.properties文件 Properties: dubbo.properties文件 配置规则： check启动时检查，消费者启动时检查相应提供者是否已经启动，未启动则报错，默认为true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; check=&quot;false&quot;&gt;&lt;/dubbo:reference&gt;````* `&lt;dubbo:consumer: ....&gt;`配置当前消费者的统一规则`&lt;dubbo:consumer: check=&quot;false&quot;&gt;&lt;/dubbo:consumer&gt;`* `&lt;dubbo:registry: check=&quot;false&quot;&gt;`注册中心启动时检查* `timeout`指定超时属性，超过timeout时间无返回则报错，默认为1000(ms) * 方法级优先，接口级次之，全局配置再次之 * 如果级别一样，则消费方优先，提供方次之* `retries=&quot;&quot;`重试次数，不包括第一次，第一次失败，再尝试retries次 * 第二次尝试会再试第一次的提供方服务器 * 第三次开始可能会更换别的服务器尝试连接## 多版本`version``version=&quot;*&quot;`随机版本运行## 本地存根在调用提供者服务之前，先验证参数符合要求才调用服务1. 创建Stub类实现要调用的接口，并在重写函数是添加判断2. xml配置,stub=&quot;&quot;```javapublic class UserServiceStub implements UserService &#123; private final UserService userService; /** * 传入userService的远程代理对象 * @param userService */ public UserServiceStub(UserService userService) &#123; super(); this.userService = userService; &#125; /*** * 本地存根 * @param userId * @return */ public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println(&quot;UserServiceStub......&quot;); if(StringUtils.isEmpty(userId))&#123; return userService.getUserAddressList(userId); &#125; return null; &#125;&#125; 1&lt;dubbo:reference interface=&quot;com.dubbo.gmall.service.UserService&quot; id=&quot;userService&quot; stub=&quot;com.dubbo.gmall.service.UserServiceStub&quot;&gt;&lt;/dubbo:reference&gt; 效果： SpringBoot与dubbo配置整合 导入dubbo-starter,在application.properties中配置属性，使用@Service暴露服务，@Reference引用服务 保留dubbo的xml配置文件 相应就可以删除MainApplication中的EnableDubbo，改为@ImportResource(locations=&quot;classpath：**&#123;url&#125;**&quot;) 去掉@Service和@Reference注解 使用API配置类配置 将每一个组件手动创建到容器中 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyDubboConfig &#123; @Bean public ApplicationConfig applicationConfig()&#123; ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(&quot;boot-user-service-provider&quot;); return applicationConfig; &#125; @Bean public RegistryConfig registryConfig()&#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(&quot;127.0.0.1:2181&quot;); registryConfig.setProtocol(&quot;zookeeper&quot;); return registryConfig; &#125; @Bean public ProtocolConfig protocolConfig()&#123; ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(&quot;dubbo&quot;); protocolConfig.setPort(20880); return protocolConfig; &#125; @Bean public ServiceConfig&lt;UserService&gt; userServiceServiceConfig(UserService userService)&#123; ServiceConfig&lt;UserService&gt; serviceConfig = new ServiceConfig&lt;&gt;(); serviceConfig.setInterface(UserService.class); serviceConfig.setRef(userService); MethodConfig methodConfig = new MethodConfig(); methodConfig.setName(&quot;getUserAddressList&quot;); methodConfig.setTimeout(1000); List&lt;MethodConfig&gt; methods=new ArrayList&lt;&gt;(); methods.add(methodConfig); serviceConfig.setMethods(methods); return serviceConfig; &#125;&#125; 高可用注册机宕机、Dubbo直连注册机宕机后，提供方与消费方可通过本地缓存达成连接 也可以直接使二者直连，而不通过注册机 负载均衡权重、轮询、、、 服务降级mock=force:return+null：调用即返回空，控制台控制“屏蔽” mock=fall:return+null：调用失败则返回空，不抛出异常，控制台“容错” 集群容错默认Failover Cluster，失败自动切换模式 Hystrix容错整合 代码阅读笔记transient将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化","categories":[],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://akatsugi.github.io/tags/dubbo/"}]},{"title":"自定义注解","slug":"自定义注解","date":"2021-11-07T11:19:53.909Z","updated":"2021-11-07T13:35:30.601Z","comments":true,"path":"2021/11/07/自定义注解/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/","excerpt":"注解类123456@Target(ElementType.METHOD) //作用于方法@Retention(RetentionPolicy.RUNTIME) // 运行时有效@Documented //被 javadoc工具记录@Inherited //可继承public @interface BatchQuery &#123;&#125;","text":"注解类123456@Target(ElementType.METHOD) //作用于方法@Retention(RetentionPolicy.RUNTIME) // 运行时有效@Documented //被 javadoc工具记录@Inherited //可继承public @interface BatchQuery &#123;&#125; 自定义注解@interface 在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口 1234@Aspect //标注增强处理类（切面类）@Component //交由Spring容器管理public @interface CherryAnnotation &#123;&#125; @pointcut注解Pointcut(切入点)： JoinPoint的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发，在程序中主要体现为书写切入点表达式。 1@Pointcut(&quot;@annotation(com.ztesoft.zsmart.pot.annotation.BatchQuery)&quot;) @Around注解@Around注解：可以用来在调用一个具体方法前和调用后来完成一些具体的任务。 =@Before+@After 1234@Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; .... &#125; 也可以不使用@pointcut 123456789101112131415161718//调用controller包下的任意类的任意方法时均会调用此方法@Around(&quot;execution(* com.company.controller.*.*(..))&quot;)public Object run1(ProceedingJoinPoint joinPoint) throws Throwable &#123; //获取方法参数值数组 Object[] args = joinPoint.getArgs(); //得到其方法签名 MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); //获取方法参数类型数组 Class[] paramTypeArray = methodSignature.getParameterTypes(); ....... logger.info(&quot;请求参数为&#123;&#125;&quot;,args); //动态修改其参数 //注意，如果调用joinPoint.proceed()方法，则修改的参数值不会生效，必须调用joinPoint.proceed(Object[] args) Object result = joinPoint.proceed(args); logger.info(&quot;响应结果为&#123;&#125;&quot;,result); //如果这里不返回result，则目标对象实际返回值会被置为null return result; &#125; 如果我们还想利用其进行参数的修改，则调用时必须用joinPoint.proceed(Object[] args)方法，将修改后的参数进行回传。如果用joinPoint.proceed()方法，则修改后的参数并不会真正被使用。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://akatsugi.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"个人博客搭建","slug":"个人博客搭建","date":"2021-11-07T10:26:21.359Z","updated":"2021-11-09T09:41:06.039Z","comments":true,"path":"2021/11/07/个人博客搭建/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"安装Nodejsnode -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本","text":"安装Nodejsnode -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本 mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n 我的第一篇文章 #创建新的文章 返回blog目录hexo clean #清理hexo g #生成 Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件配置_config.yml DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/YourGithubName/YourGithubName.github.io.gitbranch: master hexo d #部署到Github仓库里https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 修改hexo根目录下的 _config.yml 文件 ： theme: yiliahexo c #清理一下hexo g #生成hexo d #部署到远程Github仓库https://YourGithubName.github.io/ 查看博客","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://akatsugi.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"Hello World,Hexo","slug":"Hexo","date":"2021-11-07T10:25:01.681Z","updated":"2021-11-07T13:35:28.779Z","comments":true,"path":"2021/11/07/Hexo/","link":"","permalink":"https://akatsugi.github.io/2021/11/07/Hexo/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://akatsugi.github.io/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://akatsugi.github.io/tags/Docker/"},{"name":"实践","slug":"实践","permalink":"https://akatsugi.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"Spring","slug":"Spring","permalink":"https://akatsugi.github.io/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"https://akatsugi.github.io/tags/Redis/"},{"name":"dubbo","slug":"dubbo","permalink":"https://akatsugi.github.io/tags/dubbo/"},{"name":"其他","slug":"其他","permalink":"https://akatsugi.github.io/tags/%E5%85%B6%E4%BB%96/"}]}